<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"178e518119ab5f8835c42d6b6f75bd9f78e5f5467a0cbb8d492d5260253a0cf02d7166858e4ae1ce94022c53c6f3e0f7a0271d3c90ecf6e46f72165694ce2a297e24ff21a501071e9d32202f1cdcfa03f864f040049896abe0af688dd190e73d94d9615eda1bf6e6a6966c0a3b4289a5693642ebcdb1cb75fa5866daa08ae5c087a8a6734ca2c463c51807f835801978c5c14dd97ab3a1584f5c33666d7032cb006821cce3bc121b91abe83b951cd7bdb8d337064a67422b50740d0e22229da7170f7436f972d703248c0db3474a0e5425c1173a5b0039e58134b776f9dd3a3d4333c53e10d0c689714b659ffebede1f11b5f63b49d4ae5f61dea87c09500a45cf242bfd5fe0c00b069203685eef38d00b0a1c3bf65a3498e8b8254238bfc4d904f2379ebf437202fa4d2b5abc56de673fb4710746ffaddbaa27ab5da74d8c00ed70689bde8ede6cc87ba1f7848da4f8d4eb404f24e194976cb6cf6e5e9c56c52c0650f94d4994b8b6c0b89e3c1f17edc24d5292619f59b176a659f13bd3d80a65a1e71a0e683a64e021da13bdfd3358c3b0316fb8474b061a37709498ac591aa293f1be55156f5e078e8fbc4b43c492bfb69b0c988de4eed96cc628b759f6822e00f6665011210231a011ff54df6d41382b584c6a25e15a0867b7c0f5bf29dde08cdc6b54c96accc05b81285750b851d8294168a1d5dc9021b4977efdc4906eb88db0757476f0d75841a753c02758f66130c4060b8fd25f51ef343c5fea5461ba70e51d84edf25acb05e81d3c343270e85caf215e58e6684d392e2f0df1a08a37784a3827afebfc50455b2baf2232631d911477cc5b0b3cc1718eedecddad6fa75f2efec838941c9c2a34026089253a439d54963b6c79552fb93ecb60de07370d237024da15698e44cee47dbe20ad3c78fee03bc11b1aaa8fe89baca41c2ce69232804c8078995a29ca310bf7a6ab6636865aba4a8da1f3676490fe914320c8bb9fb6471396ad45fa6cfcbfa9ea163d51dc9b5dc61584b49fc6a6f3f1de8645a01ea6ebc7ddb48634fe0620a8582450ec4ea8332042f33a6044b784c763ba14ac139444db52fed6f17b4f3f159219900a508f3811fd59bcc126d26a0cc36365787242f22674e4eb805547bd4ca6d1def1102583c9bb7a828d67036a521696b616d8187e17a42bae66b4afc087becfaa09afe904ce506006c9396f0983726bf89e1a5dd62ba3f36867a72fc00abde15c510e06ca3afa4b9e700b06caea2fc9995cc8aa936d1036bc66565cf9f9bc41611292e569b09b2ce4dd9caa37b98363e2d4c9ee3767720dd45994c833cbd9d4beff3c28b16bb7a8b3373399fe997e5e61e9caac64bb6e73cef26022bf64e87972be55bc69e53eb063b1eb2bf036d36e281a8ab9c46f90ee5f6989b96e3c05987ce9beba4ba864f0fac9da7b4f624e631986f3511baf018ddc90b5a85a0d5e0e7abd409b306ce651d6a556719565eab0d2d326f9a1f075fbeefb4a442ad8a040658cc2434fa874ff17ab9494015574c84acc7990f4cb61f9c064b3acc89a72141f5f51f7e9f9b4eb51d93edd214aae898c25b2888a6689e98a604ff6f3830be2aa07554dfb60fed1a78ff8a88b6939dc97c058abd6722df7bb3a2af7506b7909f8ce1dcc68b7ee18d721b9c8626bca5e9c66314139bb04073c20ec0e47ab06007e8d60539219ce6d32603236193473013bb0fe24579f8003e3558ad859d1aaad0588e2182f3467ef1cde96aab67864fe67aa0316b8ab33da592649505b39e36ee87af9e03f0de174f19d88fa4e65796a2052c8ce5a761c585b383528dc24f494b64d24a5b29ad74c0fe5f346159325422796516cdc67022ed9786370b584791bb4816bd36f1c8966c58ab0fe414dcb4713c23fc6e10fc1d746569b26722232fde7ddd2f55dc32bb3146f56536cf6c0572c4fe61f7dd2a31940e709c4850db5389b5805860c515b1c69917e88da51820752bc25c9350a1f550ea9efe07af23157105ad18ebf71deb09216f1636da59fb36f909a687cab7c7a66d03a0d1191cd2d271ae645365b85cd499a1b73d349ff2f9481858e28d3b8d6829e83ac0be016330c56ee1f5e4e9414b75d169bf3493aaee98a23680c8456f98a31dc46e27e06151aa6ec952724269078934522015d3aba454b41aa9b30fbec096938dec889281bdef2546e28532af82245868be536e8f4f83e26f278c2db058e1e3db1773ccf9877de045a41723d7d4e022474018b2a616fc6e53b86cc3532ce91017f77e0742b8a5a6fb1abda551dd049edc9e5a8bba171d378958b0aa3bf1196301840cc0e0a671bd1bdaa7b6e561d2726c41e2153e0a2af7c508005b577a9cff2c276fa974288a040b8978d088d9d5fb373d03b9e4850f0685745f1616833703db50f5c5465edafe0e6fd93ad580ed4f27645d9db4265b4a777e81a31d78fa8e266a424a918aa16b40bfcdf588804fcb47d07967fe87d6b38af1c29bbdda0b07955d70073d75a9f4bfd3bf74f1c6156ca9578deb85ecfe1cf0d7fb1063b83425c0ea2177736d9fd1396541e0609d47dd98cafe3e54f30616436593c6d5d73c36b7e636657303fa2306f7d6e00dc4f58fb5a9174e7ebd092d902dba030d0f0852e49a4f254e018e80bf5238d61b1002bae7ae3257f89998b904f51b72fca2280cf2aef37a270beb8224cff8d11c2ea47530a672c5a1db880550f9de58008413040523d2fa938428ef6047bda4516ecbcd89b9dbadd6b96f3141544f4bbf1aef111b432869b5ece70b33d9a873dc52b8d4fe7961972903f4086974c21afb81e6f0f1fa005a162c68629cc8a4a790a2687b2b8a9cff9572539a63fba2e84758f53029c62ee2cacdeefb3a05b66313bfbc0515ab12aa5d641ad2a69b6bcc5eceebf6a537de8f0ac31cce55405cb74752f50517d5cc726d67d895022dfcb49ef63a523a4ae21bc8f36a58ccc0b8423944c164cf52b03872dee2f591b5f88b3481b70626511874382714ba4e357eda7ccdfe6ab8812bc003cfeb73a73da18eb4e3b3282540dc383b8f4a175b540893c10586bcce959fe57f3997505a4b0726130aae41d547ecbf448a7dcc140d22d7e1db847d92c96066f423b0bb8fd33ea1a919e0a9c0776b5a93759bdee4f5f02b493772cdf4cdd074aa086fddf2ab9f582d15eabfe8b975cb5371413c8909cb23c724ece664c8cf17596696f550e7ce0415ad607412ac05b48f1897baf347b59f5f0391b1540fb289eef6b66a489fc7db0747a269d9658baa2f0e1c0f643eca457faa536b00db6093d153596fd9857112df8e5d18b32d357c63a1fa94d4d816a1a47fef6747a12846d701e8763463455c97abef5832e4f4ca4637eeac5906d7e2ae549160cfba83c8f6a69ffff630eb8b9e23e26e293b5808d7499e8d8a3f57e8e06ce656029291e411205364c1e268195509f7e8d69d5f1b34fb7e3149e04bb5ae51fb90b03954da80e9f05b7bf6d9d033568bd05aa5199aebb456b1f9605d9624fc3304cd8584df838817111a9917038d0900475fadd641a3d2accb63976c4d69be8ebc463b42d50d18a4651ac11859492c371829872d5f6465880c45be1d324088a35052b36c11bb0d11c69e706a894f1a654ed536b7f6e3879380a6f49bb2361820e468e45222f0e9733cf96bd9e20eb20d05825e5a23a8bb8f3dfac20cc2401177706d3e1b7f03daa15fbfe6a9af683822649ee13b2d0a0d2662c54ba09d4d1bb3c1d920c0c05dba579273c50ba426ea1e1a4d60621a483af9bf2549f51391506922f18acfd25de0e06661838d1339c842cbfcc9c91a37943fa0ec548574e5a0ee7e35cd568d50f28a24dece528b51ac2882de2b9c047be9e8ef938b93ed75d41bd2a63d3e2d996dabf9552210fa2c9e7afbb264f462f4aceeb68f45e77fa15b49146b21b2698263abf067ab8aaaf3c4c46583255ab8cd1cc30f675dbc6f35c21eddd37fd6e79843bbfe3e2831257685f07c52a2f7199e84b7fc773c340a6cb6f6ac56d35d216f40363a2510aef9ac6afe355ccc0fbbe1022765855c2512e28e6ec8111f3cca477d9dc3c333a8ab11a465b283d1b3845b3f91808f0769be888d528658040123eacda21a0576194bc0da1c587dbbf583da5ce31fa2b5e092966e7adaf00efa3b04f6032de39aab79aded63a1cb9354a51f0d92615599e24379cbe9b846ce7c34e858d496f1f8c26dd41b92202321697884b51c0e755a951aefbcc11f76630dd0d13bc973ab1cd62a5338a2056fa699076fab1ae5600a7dd4eaa7119aa1c8b56ade2ed977a857a8c55ac6dac8ef334972ce74315f4ae2d928a71c5004122cb0d5532e2b18f459bd6c883d15f890509e57d862f930a272fc000091532300281db0597db45e4e9deb23c9d800a3c07f56a313f7b8c02aaceb2768b52990fe0d38363afa115a7838be46498a43f6fde026008a9bf81798882204fa1a0d31d9735a899bce1c549332b3f5d3e9a091292ca1a674d32fe448bfe50203ff16269dcec934f45b8dd96deefca7a99b1fc775771762aa69c8d6a1c63af8fd18f3273eee2c9678e542dae1fb8aa99e6ede80cc64e1c3ad622509f7fd37dbc3600726b493638811069a0b4fea9ee60d11de5344dee9606f12b73a2f18b9fe2f8516021f9a7ab8b89b2cf65358054ee03b33d2f7c6345757dcfbf9e22fbf83f32fb47de1d00cc972e65960466fe6ff072b95fadb48b3e8c6c0b5cfa56096cce224b52ccb55ec8cfe27d6c7bd6062001bc219a6b718244b1ab7e2e35ecfafa87c83a7118c7ec520770c2fb3e78095ce10cddc9403772e9c0d17dc2a6f10dadb1f53510acc5fecaf47b6568b3322fdd5db5c643d5b7b1eae3c8618eb472b51365a734a5e8c7deca5910c89d6a9ca1b9db8e45f4411082fcdffdf08875401cfb636d3ebdc27445ab8abddb9c6ea8de8215c8e957124afcf1e34f7e27c17d5f8dce56cadc059731ca8206c82479ae8ef64dbd05604407a8dc08caa2ed4d9f6d06152ec850bca6bed60c6505217b62d3af5a894ba43cdda05ebaac087ec499b1415c05ec66c6db18f9ee8af4a2715f3f9dec504b9adc058fe00589b84008d8c74895105cf5706c220b61cc6d14561f25ccd5dce1f8bf07199f97545910f8634f6af1c216959cdcb6793bf5e3437edfd49f1d12173fb92edf5ef7f6949beb909525f2d1f1bf036e440de4dda9d76ced1766a049841f2f4206c9337b9a1b0a2543ea2cea5a6a86bba93d17841badae47663114579fe151394ae85884b0514c8396d94999edb32146bd7ad6f4903b8a773a64d9a28e7d33babbfd7bcdddb721c0a3d0ca354922e0a68ed54a22a35a0f75c5d05ecb968f274e1d16aab55189ed930a4a7cb3e83e58157073b0510d13148446b5a0a910036bb8bc7b9ceb309a89b30cc4a6f53d12f0eef009317c8ad5040d8167f62edf9becc8bd1c865ce3856b53e9d17e23e6c6d6ae65d955c24679e4049f528125838888f8c2401d3390dd2bfada3db9e8ae068a212b3e57f0ebe36712b13cbbdad8a5523d2fd58ee0881e5b5f817588ac15932c8b478c412ee7fcb6f1f8c60fcd83e542e1d05259fb293503ba7c4a519da1cd2e60b4e0e7e804a5352ae9d9ae631e639c4de290abaea8514d5c9e6daaa698aa186c029092668363cb86a8b122991b91e0c9a13e770bd41e6ad08b89796b2951287e5f21a41df7535af6dc6d957de32f384758dde2ef1c55e98016b007222162773b402ba04e108327e0ace43255c732c7f154212ce5375bc3a9c4f527693c5919b6769ff56065b61801c2c358ffd54fbba6ccc665a649c90d6a5b49c14c5fa3265aa04d59ed9f99cc6b70d27698e33374c7e863d38f1bc028aca7615fdc15ee4983c48e9853dec52d1ec6f5cc0b577c3a2a73256617fa7cb97e6f1a119ca2ab5139b195399a72a7ef51405e417a9d62be3458602c9c309046cd7647c94fdbdc71c9ed813dffb0ebfcd8ebc585ec94bab3e0df200297f9433ca0b744c8d3c6f7a6f842986d041f4c53abafa95b90bb66134926dc27e206c94848941063e09842c4947d853138734cd25e8a110a8b35aaa877c9c4bd4d65ba9b741b33e192c6ec41fca35ff430961e2c9618dfc4ea81570b9550beac79d32be0bd87698caee4c42a8d8fe389369fb64ffe42d0aeeef51f8d8b3d9225e8c3a810c49088384e2746b77b4e4f608822104f44d21237ca92a16f17e7dd8e80a9add94f56d16367a65f4b94cd5dd44d29bcbfe93adcfdcb68b9dac87a9b8f35ea16492eb9782a0dca395298cc97de0b55540635d6c149aeb8d8849e358d2ea17f2394ba7fb4ac31bf8003f1ad2a779fdbdffb2980ade04236690792dea7de35e1178786094bd084b12bd873e45f87461c4ab4a5121b1336946471f2c5fd3f34a9161b0ddba8bbcf081b399d174678789727f4cb597e1b3a3e4d07640ebff29516d86d912ca3aab0b8d50f43884e7a586c4da03fb46a02f1dfa04768c4a5098b8c3c1dde8e9e434b7cfa57faa62f36fdff61c5c681d8bd8a7de2fb8d32b8724c9afe2c69c0390a13bbff9a6bd8fcde02b5e441dbc6632e94bf4c3a72a272977e01ef4ade0737db076b0afb2f410b268c49051d2b90f53ad0bbbcbb59c76feeb97bd475e7b7a53621569a4dafbfa8dc1ca39bb73af16fd598c763b9284651e9e047db2c5294ab6bccfc99983ba4455c290aedb3928fd76b383d146670267c18683f4aba7f5788142c721020844c89fae3ad25934e33cd1a7a3154667ed93b816cf7dc697263de525214690dff08bcaf9f8a48670340e25ce98ff94bf8079c4818aabdf74b55d0d31e1ac4b5d83675cf943ea409ae06fc17f893dc83093b5bdff80523caccb7b832e6d02b09f675562b119acfd17002984dcb9689b83eac8372a9a6f4508dde97600a849cfcb2db3fc56cf5833895d1dab79dd6c0076ffd3d059c3e973136124b2caed598cfda3fe49dcb978e77741b0be3501fb4e466f3a0d888a43ee7c031c87f49090786c2a0175271e3584499f731ba1121d9e1d98ae89e797c58b4f3a8292c6ebde4f4c1ca8fe09d62c197ea4a459c8264b3fa7b41f3c615bce396bc337bf0ed4f534365abf06afc2418385322f4177ad82dc881f92207b6ad797cce2edfb80bc386dfe60fcab13ef7472d8c651ef137730632bc0f04906b9cdfc7a9f3d22ac156972d09a6fb2c235427ed2b088e7c6286a4ce5fc571354e42d42b1c15c14614a1c9ff77f7dc95f1292f833ed486ece5e5130560e174eaf79916e1dcd29022ca9243db9e92ffeb4a2661c3a082d02aa1c81f14d037b60a70576cf5d4ce0812e9a86761ff28bc11cb1e17a0f008aa050886beab28d8f4c07db10f9d7256469133edc3bb0ef091cf72874e04295dbfbd3d81c53ab4623d79d361355a36a1b8ac35acce03d0d2ba2e387ae629fb063c09412290ffa1a3651323af0193f24f903363ae07610f1ea5a55ef699d2400bfa6e7241af3f2814fc0cda1949d242707e25b859aca5e8b745e9571ce69c4e1fd0dba26ab7f9bd90fdcf2607d86e3d4ad3547b4abef605c903bc555cf70c94df3a3774ac2eeefed4d4040b8354a7b4e28cb336381c4d486012927bd0e344ad8ed96576eadb000a7c72d7e61f5bc3b9b033e29035e3ef0dc3b6ebead1c3833883c84a53ed9ee7707828ac114ab4f68fb0a4a7f6c5ab548513f7b47de0ed7ec814aef4122da8306f9d6d70109666e5f7ee6b2db1d31df24a111b60e99373159b7b3691033abab72efe5f1ede8fffba136572dd41d7d170684e715697a365806d7a1179bdacd3b725be91eaa580f042065f0acfa0f75a9878105634c6aa2f55f4b71f55cb2365cc8da68989ec04f44ea6e1fe4f9b28495f7a7913e0100d44e464627b6ece37157a18d11776dfd967bb9fa1ca6e1d4e7cf7fa993c949cc3672877ecc13432da4a97288edbd49554d1da69d14ef385afba8e107bb364f0eb84bc76c9e3e20453aa9c6be24d85e521a9fc28006b79e4bb417fdecb410bcdf7a890feb83c0b1dc5c01b8a5da3ff2527cbe1e0a7a2bc06ba7db9030f170725e8cbc80220b9f0abef17c17e6bb089341164ef2ae17446ab73646943089a2b7c75ddf1c53a428a0f66119f064e304798f36217897abf414f4b769b4e0cd92ca5c61424ebc0347ad2fb7f5eeb2054f0561b8543d88bc9d3e848e0142351b04795ac10a5863a2a691b6012eb89096da7540cc137de3d64bfe684d879ea90e18821482454b44ccb509a11a0ac32027fe435cf8ba32d9e6b5b07247d505fbdc7f9ab1ccb8ad509dc81be34c5f83e238d5fb81005704e1ea83fa9e1ff9ed2d9d26b6b9104f1d3a22b9957a94455d00c7de2342ea711df2a5498a25de7ae2e92fe5c100af179b4dc7249e2c400cb3f896d791e871913bd00ef25389b9b5cf0fffcd828b7afc5a5affcbb59924c517b388afa6ef9471533e6e1df6a41818c011c741e4b52f70d7ed24f199789588f4797f944a2183490922009767ad8335ccc6e896085e961e02138a163e0c84eebe42bc10d8888522c275121abf121c19c0413a3223786420288a321bfc16976d4b695f77bee930067bebb5ac9c2ee1a0814f18ca187861893bc9871db6a3893bc8237657f9366efac354f2815c44299b82a038c97bb03ce71d912fcbd8283f8dab491e0ff59a4383fd1200234074194c546fc694d9f4e277330dd35119919a430fad7812790147f48e4e1a3a3eae08d553a69696f50016d28d1750c9aa867d84754f6a56f4a6642d264bd1f4c83e510bf68d20d95cf44ce0edc312af3a01f02736686cde6bb04e8ca7b69636f3317e90489d4ca89ef9d0faa62abae79fe3209a2b4ac072380926d578e2b09c85bd416ec352dde93aa514296139cb5b0567c6fa7309dfbec7651382871d463ef6151c334ce5800b16f6152b8945b2d31cceb09b8528e03748093f6fb7b2ccaf34b4b33718ae38ad0ebf68355eeeddce7540248b12d11437f06dfd89adbabf05e2bd710524cc1218acdc65fa16b7bd185ab622bce3ad89d1e8b5edb50946d7a5984c36b5a302c6290d8a900ca928a97683cf55acc4ebd17c28e9224e53968e1cbca262d0c553af6b2f4f847156ce77049beab6fbfb70ee82f0cb101cdb971d0c86e48b7f2ff470cf8b1f96d2c82fa0b79cc967024fa566aa59e27d7ee3c216afd6876c55776379dd8bc3843dddd6263154c6f3e0126cded7bf35721f4a1800f7d1fd2c3906a14afb7f84f1fc05ee529bdb9a181846a79705610dcc770452d03245f3457372602d9e4a32f5a7b7c365b273357f65f4169dea2059660aba45d741bdb2f9da038eb3275b0b7973693ad388c037f60b513ae8c2b220b8fba2667776ad03d2bf8984bfe15d8cef3d20b0bae78cbf686f2315d15f7948b78d08a8d5a6009810a35776f71f1fa3f9acc95bdea6c115e898cf4826c00c44d08edb38fe17d89557b54532baca4d3214fea72dd0c35d7b090c08d8194eb190dc5e5e0d9946cbf5d032d1e6739258307e7ca3e4ee13d81821023c59f93e4d8359c56f413d7714b9adba847af830da6ad1f79334eb5d9866c793c60760b5a13360526cd740c263ee44bf9797425d1a176f37c6b4dfdbb9e5eaa1070b7773c2a9a3470abe3bebdd4f08a38d77a238fc3e9108706b22fe8c63a09b6c08054b4f8779f6f46532b9e4b8dc7fab5b2e0ea8227958afdf33acd55ae44951a8030f9050d9928333cb177813e0d0e2a837b326cc0f868d4be9069f87bd47529152dc2f19c6aab9797704dbd00c69935a3dcb7d17d9ec708f687662936e9ebee47e0c6b2b27cf0cbd08e29f9ccc7fcffee07f296a55f2c268d4bc237d06afc19242fbdd27892d8d710bd19b3fa233be56413bcf9bde4b3c0a93576f6d777821364370ff80ef483f25ff506fd9f7410201bfaf3e0929dae4473cb904aca47fb40e5a4203e4d03391a331b8819161f89dd4894aa2476686b3752a0e12e7f2661f96d46739f6e451fc3a296e6c45442871e21f7261da784c2d0f23d4abd5594ec21225cf70fa79c843acdfa0b2a9b988abd34164ce7f206e341e06c44b647a975904c852650fdf9e2e5757243ceb29fa2390c5f4437f93a442320aa7a3fb18f20c444f709091a823d0c5065a084c90be889561ef22b111ceec72805266cc0df935aa1af00f54db2ef8e3f246e9112ae55eff824ec2efb972a4a0a931d781c39354d178648b5f79642bac3849f81b2a8d9e68dee2edc81095748445f2006e3fecc0e82636ce0d782920a62a251f54210fde66ebc722d44b468d8e14e62d05a6d6c9cb47345442a5e32b342c8501878eb8d8e549c3c7ad10165ead04bf51e70eb3984dec49aa069a35ad630dc98c42411117fc5ade79d8923af9cd355b1789896a6878599b389d2ed8d30243dad60afda6087bf677f6f9c61f6a95d2a1b56636e7acd6dc973465b9a0d0900c096dc688e3da0fadea4db9f8527fd3acdf6f0504e11cd85d10ab332bcfe041f8e1ffc473d7843e8fa228852e78ef3e8ae408e6cea3104fd3d1755c286a72d4250818c2864f0c2065dd91c7c8e637fb59bdc8ba32c336a190283901d8deb4c42e1cdaedf9ef89c20184cc628041e70707349740db10b6c2b0d7afc35857c05ac3c29b79dc29a5ebf64af899b","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ff6af2a6e5e94efe61e371daf9920e0b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
